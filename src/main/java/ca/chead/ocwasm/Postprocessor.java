package ca.chead.ocwasm;

import asmble.ast.Node;
import asmble.compile.jvm.ClsContext;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.nio.Buffer;
import java.nio.ByteBuffer;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Objects;
import java.util.StringJoiner;
import java.util.stream.StreamSupport;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.FieldInsnNode;
import org.objectweb.asm.tree.InsnList;
import org.objectweb.asm.tree.InsnNode;
import org.objectweb.asm.tree.IntInsnNode;
import org.objectweb.asm.tree.JumpInsnNode;
import org.objectweb.asm.tree.LabelNode;
import org.objectweb.asm.tree.LdcInsnNode;
import org.objectweb.asm.tree.LookupSwitchInsnNode;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.MethodNode;
import org.objectweb.asm.tree.TableSwitchInsnNode;
import org.objectweb.asm.tree.TypeInsnNode;
import org.objectweb.asm.tree.VarInsnNode;
import org.objectweb.asm.tree.analysis.Analyzer;
import org.objectweb.asm.tree.analysis.AnalyzerException;
import org.objectweb.asm.tree.analysis.BasicInterpreter;
import org.objectweb.asm.tree.analysis.BasicValue;
import org.objectweb.asm.tree.analysis.Frame;
import org.objectweb.asm.tree.analysis.SimpleVerifier;
import org.objectweb.asm.util.Textifier;
import org.objectweb.asm.util.TraceMethodVisitor;

/**
 * Provides functions for postprocessing a Java class generated by Asmble into
 * a form useful for executing in the OC-Wasm architecture.
 */
public final class Postprocessor {
	/**
	 * Metadata returned by the postprocessor.
	 */
	public static final class Result {
		/**
		 * The “fixed memory size” of the module instance.
		 *
		 * This is meant to be a rough estimate of how much space the
		 * fixed-size contents of an instance of the module take up. Therefore:
		 * <ul>
		 * <li>Functions are included.</li>
		 * <li>Tables are included.</li>
		 * <li>Linear memory is excluded, because it is variable-size.</li>
		 * <li>Data segments are excluded, because they are counted in the size
		 * of linear memory.</li>
		 * <li>Custom sections are excluded, because they do not form part of
		 * the runtime module instance.</li>
		 * </ul>
		 *
		 * This number is not exact; it is computed by starting with the total
		 * binary size and subtracting excluded portions.
		 */
		public final int fixedMemorySize;

		/**
		 * Constructs a new {@code Result}.
		 *
		 * @param fixedMemorySize The fixed memory size.
		 */
		public Result(final int fixedMemorySize) {
			super();
			this.fixedMemorySize = fixedMemorySize;
		}
	}

	/**
	 * The Type for Buffer.
	 */
	private static final Type BUF_TYPE = Type.getType(Buffer.class);

	/**
	 * The Type for ByteBuffer.
	 */
	private static final Type BB_TYPE = Type.getType(ByteBuffer.class);

	/**
	 * The Type for {@link ModuleConstructionListener}.
	 */
	private static final Type LISTENER_TYPE = Type.getType(ModuleConstructionListener.class);

	/**
	 * The Type for {@link ModuleBase}.
	 */
	private static final Type MODULE_BASE_TYPE = Type.getType(ModuleBase.class);

	/**
	 * A zero-length array of {@code String}.
	 *
	 * This is used to avoid unnecessary allocations.
	 */
	public static final String[] ZERO_STRINGS = new String[0];

	/**
	 * Postprocesses a class.
	 *
	 * This method should be invoked after the class is generated by Asmble and
	 * before it is used.
	 *
	 * @param node The class to postprocess.
	 * @param module The Wasm module from which {@code node} was generated.
	 * @param binary The Wasm binary from which {@code module} was parsed.
	 * @param context The class context used for compiling.
	 * @return Extra computed metadata.
	 * @throws PostprocessException If something goes wrong during
	 * postprocessing.
	 */
	public static Result postprocess(final ClassNode node, final Node.Module module, final byte[] binary, final ClsContext context) throws PostprocessException {
		// Sanity check.
		Objects.requireNonNull(node);
		Objects.requireNonNull(module);
		Objects.requireNonNull(context);

		// Sanity check: we only support importing functions, not tables,
		// memories, or globals (we allow defining all of the above, just not
		// importing external ones).
		if(!module.getImports().stream().allMatch(i -> i.getKind() instanceof Node.Import.Kind.Func)) {
			throw new PostprocessException("Imports other than functions are not supported");
		}

		// Sanity check: there must be exactly one linear memory.
		{
			final int memories = module.getMemories().size();
			if(memories == 0) {
				throw new PostprocessException("There must be a linear memory");
			} else if(memories != 1) {
				throw new PostprocessException("Multiple linear memories are not supported");
			}
		}

		// Sanity check: there must be at most one table.
		if(module.getTables().size() > 1) {
			throw new PostprocessException("Multiple tables are not supported");
		}

		// Set the proper superclass.
		node.superName = MODULE_BASE_TYPE.getInternalName();

		// Since we have a memory, Asmble creates three constructors:
		// - CompiledClass(MethodHandle import0, …)
		// - CompiledClass(int maxMemorySize, MethodHandle import0, …)
		// - CompiledClass(ByteBuffer memory, MethodHandle import0, …)
		//
		// The first delegates to the second and the second delegates to the
		// third. We will only use the third, so to avoid confusion, delete the
		// first two.
		{
			final Iterator<MethodNode> iter = node.methods.iterator();
			while(iter.hasNext()) {
				final MethodNode i = iter.next();
				if(i.name.equals("<init>") && constructorDelegates(i, node)) {
					iter.remove();
				}
			}
		}

		// Sanity check: there should now be exactly one constructor.
		if(node.methods.stream().filter(i -> i.name.equals("<init>")).count() != 1) {
			throw new PostprocessException("There must be exactly one non-delegating constructor (this is an OC-Wasm bug)");
		}

		// Process the methods generated from Wasm-binary-defined functions,
		// but not other methods (e.g. constructors, wrappers, etc.).
		{
			final int numImportedFunctions = module.getImports().size();
			final int numDefinedFunctions = module.getFuncs().size();
			final Analyzer<BasicValue> analyzer = new Analyzer<BasicValue>(new BasicInterpreter());
			for(int i = numImportedFunctions; i != numImportedFunctions + numDefinedFunctions; ++i) {
				final String methodName = context.funcName(i);
				final MethodNode method = node.methods.stream().filter(j -> j.name.equals(methodName)).findAny().orElseThrow(() -> new PostprocessException("Method " + methodName + " not found in compiled code (this is an OC-Wasm bug)"));

				// Populate the local variable and stack entry counts.
				try {
					analyzer.analyzeAndComputeMaxs(node.name, method);
				} catch(final AnalyzerException exp) {
					throw new PostprocessException("Error postprocessing method " + methodName + " (this is an OC-Wasm bug)", exp);
				}

				// Add the timeout and stack depth checks. Note that the method can
				// throw ExecutionException and WrappedException.
				addTimeoutChecks(method);
				addStackDepthChecks(method);
				addThrows(method, ExecutionException.class);
				addThrows(method, WrappedException.class);
			}
		}

		// If there is a start function, then mark that the constructor can
		// throw ExecutionException and WrappedException as well, because it
		// delegates to a user-provided Wasm function.
		if(module.getStartFuncIndex() != null) {
			node.methods.stream().filter(i -> i.name.equals("<init>")).forEach(i -> {
				addThrows(i, ExecutionException.class);
				addThrows(i, WrappedException.class);
			});
		}

		// Add the saveMutableGlobals method.
		addSaveMutableGlobalsMethod(node, module);

		// Fix the constructor.
		fixConstructor(node.methods.stream().filter(i -> i.name.equals("<init>")).findAny().get(), node, module);

		// Sanity check: run a verifier over all methods in the class to make
		// sure we didn’t break anything.
		{
			final Analyzer<BasicValue> analyzer = new Analyzer<BasicValue>(new SimpleVerifier(Type.getObjectType(node.name), MODULE_BASE_TYPE, false));
			for(final MethodNode i : node.methods) {
				try {
					analyzer.analyzeAndComputeMaxs(node.name, i);
				} catch(final AnalyzerException exp) {
					final int failingInsnIndex = i.instructions.indexOf(exp.node);
					final int printFromIndex = Math.max(0, failingInsnIndex - 3);
					final int printToIndex = failingInsnIndex;
					final StringBuilder sb = new StringBuilder();
					sb.append("After postprocessing, method ");
					sb.append(i.name);
					sb.append(" failed verification; stack and bytecode leading up to failure:\n");
					final Textifier textifier = new Textifier();
					final TraceMethodVisitor tmv = new TraceMethodVisitor(textifier);
					for(int j = printFromIndex; j <= printToIndex; ++j) {
						sb.append("stack: ");
						final Frame<BasicValue> frame = analyzer.getFrames()[j];
						final StringJoiner sj = new StringJoiner(", ", "[", "]");
						for(int k = 0; k != frame.getStackSize(); ++k) {
							sj.add(frame.getStack(k).toString());
						}
						sb.append(sj.toString());
						sb.append('\n');

						sb.append("insn:  ");
						i.instructions.get(j).accept(tmv);
						sb.append(textifier.text.get(0));
						textifier.text.clear();
					}
					throw new PostprocessException(sb.toString(), exp);
				}
			}
		}

		// Sanity check.
		checkAllAbstractMethodsOverridden(node);

		// Calculate the fixed memory size.
		final int fixedMemorySize = binary.length
			- module.getData().stream().mapToInt(i -> i.getData().length).sum()
			- module.getCustomSections().stream().mapToInt(i -> i.getName().length() + i.getPayload().length).sum();
		return new Result(fixedMemorySize);
	}

	/**
	 * Adds timeout checks where needed to a method.
	 *
	 * Straight-line code cannot exceed any reasonable time limit because the
	 * amount of RAM available in a computer is small enough that execution
	 * will reach the end of the binary quite quickly. The only way to actually
	 * take up a lot of time is via the use of loops or function calls.
	 * Therefore, this function adds a timeout check at the top of each
	 * function or loop.
	 *
	 * @param method The method to modify.
	 */
	private static void addTimeoutChecks(final MethodNode method) throws PostprocessException {
		// Collect all the label nodes that are targets of backwards jumps.
		final HashSet<AbstractInsnNode> locationsToAdd = new HashSet<AbstractInsnNode>();
		{
			final HashSet<LabelNode> labelsSeen = new HashSet<LabelNode>();
			for(final AbstractInsnNode i : method.instructions) {
				if(i instanceof LabelNode) {
					labelsSeen.add((LabelNode) i);
				} else if(i instanceof JumpInsnNode) {
					checkControlTransferForTimeout(labelsSeen, ((JumpInsnNode) i).label, locationsToAdd);
				} else if(i instanceof LookupSwitchInsnNode) {
					for(final LabelNode j : ((LookupSwitchInsnNode) i).labels) {
						checkControlTransferForTimeout(labelsSeen, j, locationsToAdd);
					}
				} else if(i instanceof TableSwitchInsnNode) {
					final TableSwitchInsnNode tsin = (TableSwitchInsnNode) i;
					for(final LabelNode j : tsin.labels) {
						checkControlTransferForTimeout(labelsSeen, j, locationsToAdd);
					}
					checkControlTransferForTimeout(labelsSeen, tsin.dflt, locationsToAdd);
				} else if(i.getOpcode() == Opcodes.RET) {
					// Asmble, at time of writing, never generates JSR/RET
					// instructions. It seems likely that it will not do so in
					// future either, because the JVM specification says they
					// are deprecated.
					throw new PostprocessException("Generated bytecode contains unsupported RET instruction (this is an OC-Wasm bug)");
				}
			}
		}

		// Add the very start of the function.
		locationsToAdd.add(method.instructions.getFirst());

		// Consider the following:
		//
		// f():
		// label1:
		// label2:
		// label3:
		// <loop body>
		// ifeq label2
		// <loop body>
		// ifeq label3
		// <loop body>
		// goto label1
		//
		// In this scenario, we would add three nodes to locationsToAdd:
		// 1. label1, because it is at the top of the function and because it
		//    is the target of the goto.
		// 2. label2, because it is the target of an ifeq.
		// 3. label3, because it is the target of an ifeq.
		// However, these three nodes actually identify the same real
		// instruction. There is no point generating three timeout checks at
		// these three locations. Instead, walk each location forward until we
		// reach a real instruction (i.e. one that is not a label, stack map,
		// or other pseudo-instruction), which will collapse these three nodes
		// into a single node (the first instruction of the loop body), and add
		// the timeout check there.
		final HashSet<AbstractInsnNode> advancedLocations = new HashSet<AbstractInsnNode>();
		for(AbstractInsnNode i : locationsToAdd) {
			// While it’s not actually documented in the ASM Javadocs, it so
			// happens that all pseudo-instructions have negative opcodes. This
			// seems like a safe heuristic; no actual real opcode can ever be
			// negative. We might fail to recognize a pseudo-instruction in
			// future if it is given a positive opcode, but that merely reduces
			// efficiency by potentially generating extra timeout checks; it
			// doesn’t break correctness.
			while(i.getOpcode() < 0) {
				i = i.getNext();
			}
			advancedLocations.add(i);
		}

		// Insert the timeout check at each specified location. At this point
		// the pointed-to nodes are physical instructions, and the timeout
		// checks should be added immediately above them.
		for(final AbstractInsnNode i : advancedLocations) {
			final InsnList il = new InsnList();
			// Stack: empty
			il.add(new VarInsnNode(Opcodes.ALOAD, 0));
			// Stack: ModuleBase this
			il.add(new FieldInsnNode(Opcodes.GETFIELD, MODULE_BASE_TYPE.getInternalName(), "timedOut", Type.BOOLEAN_TYPE.getDescriptor()));
			// Stack: boolean timedOut
			final JumpInsnNode jump = new JumpInsnNode(Opcodes.IFEQ, null);
			il.add(jump);
			// Stack: empty
			il.add(new TypeInsnNode(Opcodes.NEW, Type.getInternalName(TimeoutException.class)));
			// Stack: TimeoutException exp
			il.add(new InsnNode(Opcodes.DUP));
			// Stack: TimeoutException exp, TimeoutException exp
			il.add(new MethodInsnNode(Opcodes.INVOKESPECIAL, Type.getInternalName(TimeoutException.class), "<init>", Type.getMethodDescriptor(Type.VOID_TYPE)));
			// Stack: TimeoutException exp
			il.add(new InsnNode(Opcodes.ATHROW));
			// Stack: irrelevant
			final LabelNode skipLabel = new LabelNode();
			jump.label = skipLabel;
			il.add(skipLabel);
			// Stack: empty
			method.instructions.insertBefore(i, il);
		}
	}

	/**
	 * Checks whether a label should be added to the list of locations at which
	 * to insert a timeout check and, if so, adds it there.
	 *
	 * @param labelsSeen The set of labels that have appeared in the
	 * instruction stream so far.
	 * @param label The target of the control transfer instruction under
	 * consideration.
	 * @param locationsToAdd The set of labels at which a timeout check will be
	 * added, to which the label is added if appropriate.
	 */
	private static void checkControlTransferForTimeout(final HashSet<LabelNode> labelsSeen, final LabelNode label, final HashSet<AbstractInsnNode> locationsToAdd) {
		if(labelsSeen.contains(label)) {
			// The label already appeared in the instruction stream before the
			// instruction that refers to it. That means the control transfer
			// goes backwards, and therefore may be part of a loop.
			locationsToAdd.add(label);
		} else {
			// The label has not appeared in the instruction stream yet. That
			// means the control transfer goes forwards. We do not need to add
			// a timeout check add that label. The control transfer might not
			// be related to a loop at all, and if it is, some other backwards
			// control transfer must appear elsewhere.
		}
	}

	/**
	 * Adds stack depth checking and accounting to a method.
	 *
	 * @param method The method to modify.
	 */
	private static void addStackDepthChecks(final MethodNode method) {
		// Calculate the number of words that this method is considered to
		// consume. This includes locals, operand stack slots, and one for the
		// return address.
		final int cost = method.maxLocals + method.maxStack + 1;

		// At the top of the method, subtract this cost from the free memory
		// and, if the result is negative, throw a StackOverflowException.
		{
			final InsnList il = new InsnList();
			// Stack: empty
			il.add(new VarInsnNode(Opcodes.ALOAD, 0));
			// Stack: ModuleBase this
			il.add(new InsnNode(Opcodes.DUP));
			// Stack: ModuleBase this, ModuleBase this
			il.add(new FieldInsnNode(Opcodes.GETFIELD, MODULE_BASE_TYPE.getInternalName(), "freeMemory", Type.INT_TYPE.getDescriptor()));
			// Stack: ModuleBase this, int freeMemory
			il.add(pushConstant(cost));
			// Stack: ModuleBase this, int freeMemory, int cost
			il.add(new InsnNode(Opcodes.ISUB));
			// Stack: ModuleBase this, int newFreeMemory
			il.add(new InsnNode(Opcodes.DUP));
			// Stack: ModuleBase this, int newFreeMemory, int newFreeMemory
			final JumpInsnNode jump = new JumpInsnNode(Opcodes.IFGE, null);
			il.add(jump);
			// Stack: ModuleBase this, int newFreeMemory
			il.add(new TypeInsnNode(Opcodes.NEW, Type.getInternalName(StackOverflowException.class)));
			// Stack: ModuleBase this, int newFreeMemory, StackOverflowException exp
			il.add(new InsnNode(Opcodes.DUP));
			// Stack: ModuleBase this, int newFreeMemory, StackOverflowException exp, StackOverflowException exp
			il.add(new MethodInsnNode(Opcodes.INVOKESPECIAL, Type.getInternalName(StackOverflowException.class), "<init>", Type.getMethodDescriptor(Type.VOID_TYPE)));
			// Stack: ModuleBase this, int newFreeMemory, StackOverflowException exp
			il.add(new InsnNode(Opcodes.ATHROW));
			// Stack: irrelevant
			final LabelNode skipLabel = new LabelNode();
			jump.label = skipLabel;
			il.add(skipLabel);
			// Stack: ModuleBase this, int newFreeMemory
			il.add(new FieldInsnNode(Opcodes.PUTFIELD, MODULE_BASE_TYPE.getInternalName(), "freeMemory", Type.INT_TYPE.getDescriptor()));
			// Stack: empty
			method.instructions.insert(il);
		}

		// Immediately before each return instruction, add the cost back to the
		// free memory.
		for(final AbstractInsnNode i : method.instructions) {
			if(isReturn(i.getOpcode())) {
				final InsnList il = new InsnList();
				// Stack: empty
				il.add(new VarInsnNode(Opcodes.ALOAD, 0));
				// Stack: ModuleBase this
				il.add(new InsnNode(Opcodes.DUP));
				// Stack: ModuleBase this, ModuleBase this
				il.add(new FieldInsnNode(Opcodes.GETFIELD, MODULE_BASE_TYPE.getInternalName(), "freeMemory", Type.INT_TYPE.getDescriptor()));
				// Stack: ModuleBase this, int freeMemory
				il.add(pushConstant(cost));
				// Stack: ModuleBase this, int freeMemory, int cost
				il.add(new InsnNode(Opcodes.IADD));
				// Stack: ModuleBase this, int newFreeMemory
				il.add(new FieldInsnNode(Opcodes.PUTFIELD, MODULE_BASE_TYPE.getInternalName(), "freeMemory", Type.INT_TYPE.getDescriptor()));
				// Stack: empty
				method.instructions.insertBefore(i, il);
			}
		}
	}

	/**
	 * Checks whether an instruction is a return instruction.
	 *
	 * @param opcode The instruction opcode.
	 * @return {@code true} if the instruction is a return, or {@code false} if
	 * it is anything else.
	 */
	private static boolean isReturn(final int opcode) {
		switch(opcode) {
			case Opcodes.RETURN: return true;
			case Opcodes.IRETURN: return true;
			case Opcodes.LRETURN: return true;
			case Opcodes.FRETURN: return true;
			case Opcodes.DRETURN: return true;
			case Opcodes.ARETURN: return true;
			default: return false;
		}
	}

	/**
	 * Generates an instruction to push an integer constant.
	 *
	 * @param value The integer value.
	 * @return An instruction node representing the most efficient way to push
	 * {@code value} to the stack.
	 */
	@SuppressWarnings("checkstyle:MagicNumber") // Magic numbers are kinda the point of this method.
	private static AbstractInsnNode pushConstant(final int value) {
		if(value == -1) {
			return new InsnNode(Opcodes.ICONST_M1);
		} else if(value == 0) {
			return new InsnNode(Opcodes.ICONST_0);
		} else if(value == 1) {
			return new InsnNode(Opcodes.ICONST_1);
		} else if(value == 2) {
			return new InsnNode(Opcodes.ICONST_2);
		} else if(value == 3) {
			return new InsnNode(Opcodes.ICONST_3);
		} else if(value == 4) {
			return new InsnNode(Opcodes.ICONST_4);
		} else if(value == 5) {
			return new InsnNode(Opcodes.ICONST_5);
		} else if(Byte.MIN_VALUE <= value && value <= Byte.MAX_VALUE) {
			return new IntInsnNode(Opcodes.BIPUSH, value);
		} else if(Short.MIN_VALUE <= value && value <= Short.MAX_VALUE) {
			return new IntInsnNode(Opcodes.SIPUSH, value);
		} else {
			return new LdcInsnNode(value);
		}
	}

	/**
	 * Adds an exception to a method’s {@code throws} clause.
	 *
	 * @param method The method to modify.
	 * @param exception The exception that can be thrown.
	 */
	private static void addThrows(final MethodNode method, final Class<? extends Exception> exception) {
		final String className = Type.getInternalName(exception);
		if(!method.exceptions.contains(className)) {
			method.exceptions.add(className);
		}
	}

	/**
	 * Adds the {@code saveMutableGlobals} method to the class.
	 *
	 * @param node The Wasm module class to modify.
	 * @param module The original Wasm module.
	 * @throws PostprocessException If a problem happens during postprocessing.
	 */
	private static void addSaveMutableGlobalsMethod(final ClassNode node, final Node.Module module) throws PostprocessException {
		// Make sure there isn’t already a saveMutableGlobals method.
		if(node.methods.stream().anyMatch(i -> i.name.equals("saveMutableGlobals"))) {
			throw new PostprocessException("Wasm module exports reserved function name “saveMutableGlobals”");
		}

		final MethodNode method = new MethodNode(Opcodes.ASM9, Opcodes.ACC_PUBLIC | Opcodes.ACC_FINAL | Opcodes.ACC_SYNTHETIC, "saveMutableGlobals", Type.getMethodDescriptor(Type.VOID_TYPE, BB_TYPE), null, ZERO_STRINGS);
		final InsnList il = method.instructions;

		// Stack: empty
		il.add(new VarInsnNode(Opcodes.ALOAD, 1));
		// Stack: ByteBuffer(buffer)

		// Write the globals into the buffer.
		final List<Node.Global> globals = module.getGlobals();
		for(int i = 0; i != globals.size(); ++i) {
			final Node.Type.Global global = globals.get(i).getType();
			if(global.getMutable()) {
				// Stack: ByteBuffer(buffer)
				il.add(new VarInsnNode(Opcodes.ALOAD, 0));
				// Stack: ByteBuffer(buffer), this
				il.add(new FieldInsnNode(Opcodes.GETFIELD, node.name, "$global" + i, convertValueType(global.getContentType()).getDescriptor()));
				// Stack: ByteBuffer(buffer), globalValue
				il.add(new MethodInsnNode(Opcodes.INVOKEVIRTUAL, BB_TYPE.getInternalName(), "put" + getByteBufferMethodSuffix(global.getContentType()), Type.getMethodDescriptor(BB_TYPE, convertValueType(global.getContentType())), false));
				// Stack: ByteBuffer(buffer)
			}
		}
		// Stack: ByteBuffer(buffer)

		il.add(new InsnNode(Opcodes.RETURN));

		node.methods.add(method);
	}

	/**
	 * Fixes the constructor.
	 *
	 * This method makes the following changes:
	 * <ul>
	 * <li>adds two new parameters, of type {@link ModuleConstructionListener}
	 * and {@link ByteBuffer} (the latter to hold a snapshot to restore),</li>
	 * <li>changes the superclass constructor call to refer to {@link
	 * ModuleBase} instead of {@link Object},</li>
	 * <li>adds the {@link ModuleConstructionListener} parameter to the
	 * superclass constructor call, and</li>
	 * <li>adds logic to skip the start function (if present) and restore from
	 * the snapshot {@link ByteBuffer} instead if the latter was provided.</li>
	 * </ul>
	 *
	 * @param ctor The constructor to modify.
	 * @param node The class to modify.
	 * @param module The original Wasm module.
	 * @throws PostprocessException If something goes wrong during postprocessing.
	 */
	private static void fixConstructor(final MethodNode ctor, final ClassNode node, final Node.Module module) throws PostprocessException {
		// Count its parameters.
		final int originalParams = Type.getArgumentsAndReturnSizes(ctor.desc) >> 2;

		// At time of writing, the following statements are true:
		// - Asmble does not add any locals to the constructor. The only locals
		//   present are the parameters (including this).
		// - There is only one RETURN instruction, at the very end of the
		//   constructor.
		// - There are no branch instructions.
		// - If there is a start function, it is invoked immediately prior to
		//   the RETURN instruction, by means of an ALOAD plus an
		//   INVOKEVIRTUAL (if the start function is defined then it is ALOAD
		//   this plus INVOKEVIRTUAL the function; if it is an import, it is
		//   ALOAD the parameter plus INVOKEVIRTUAL the MethodHandle’s
		//   invokeExact method).
		//
		// Verify the first three bullet points. This might fail if a future
		// version of Asmble changes the layout of the constructor, in which
		// case we want to fail because we can’t reliably rewrite it to the
		// form we want.
		final InsnList il = ctor.instructions;
		if(StreamSupport.stream(il.spliterator(), false).anyMatch(i -> i instanceof VarInsnNode && ((VarInsnNode) i).var >= originalParams)) {
			throw new PostprocessException("Constructor has locals other than its parameters, which are not supported (this is an OC-Wasm bug)");
		}
		if(StreamSupport.stream(il.spliterator(), false).filter(i -> i.getOpcode() == Opcodes.RETURN).count() != 1) {
			throw new PostprocessException("Constructor does not have exactly one RETURN instruction, which is not supported (this is an OC-Wasm bug)");
		}
		if(StreamSupport.stream(il.spliterator(), false).anyMatch(i -> i instanceof JumpInsnNode || i instanceof LookupSwitchInsnNode || i instanceof TableSwitchInsnNode)) {
			throw new PostprocessException("Constructor contains a branch instruction, which is not supported (this is an OC-Wasm bug)");
		}

		// Verify that the last instruction is RETURN and remove it. We’ll add
		// our own RETURN later after rewriting things.
		{
			final AbstractInsnNode returnInsn = il.getLast();
			if(returnInsn.getOpcode() != Opcodes.RETURN) {
				throw new PostprocessException("Constructor’s last instruction is not RETURN (this is an OC-Wasm bug)");
			}
			il.remove(returnInsn);
		}

		// If there is a start function, verify the fourth bullet point and
		// remove the ALOAD and INVOKEVIRTUAL instructions from the method.
		// Save the removed instructions, if any, in a list.
		final InsnList callStartFunctionInsns = new InsnList();
		if(module.getStartFuncIndex() != null) {
			final AbstractInsnNode invokeInsn = il.getLast();
			if(invokeInsn == null || invokeInsn.getOpcode() != Opcodes.INVOKEVIRTUAL) {
				throw new PostprocessException("Constructor’s second-last instruction is not INVOKEVIRTUAL (this is an OC-Wasm bug)");
			}
			final AbstractInsnNode aloadInsn = invokeInsn.getPrevious();
			if(aloadInsn == null || aloadInsn.getOpcode() != Opcodes.ALOAD) {
				throw new PostprocessException("Constructor’s third-last instruction is not ALOAD (this is an OC-Wasm bug)");
			}
			il.remove(aloadInsn);
			il.remove(invokeInsn);
			callStartFunctionInsns.add(aloadInsn);
			callStartFunctionInsns.add(invokeInsn);
		}

		// Add parameters of type ModuleConstructionListener and ByteBuffer.
		final int listenerParamIndex;
		final int bufferParamIndex;
		{
			final Type[] originalArguments = Type.getArgumentTypes(ctor.desc);
			final Type[] newArguments = new Type[originalArguments.length + 2];
			System.arraycopy(originalArguments, 0, newArguments, 0, originalArguments.length);
			listenerParamIndex = originalArguments.length;
			newArguments[listenerParamIndex] = LISTENER_TYPE;
			bufferParamIndex = listenerParamIndex + 1;
			newArguments[bufferParamIndex] = BB_TYPE;
			ctor.desc = Type.getMethodDescriptor(Type.VOID_TYPE, newArguments);
		}

		// Calculate the local indices at which the new parameters appear.
		// These are one higher than their parameter indices because local zero
		// is “this”, which is not considered a parameter.
		final int listenerLocalIndex = listenerParamIndex + 1;
		final int bufferLocalIndex = bufferParamIndex + 1;

		// Fix the superclass constructor call. This will appear as an
		// INVOKESPECIAL. We need to (1) change the superclass method
		// reference, and (2) add an ALOAD in front of it to pass the
		// ModuleConstructionListener.
		{
			final MethodInsnNode invoke = (MethodInsnNode) StreamSupport.stream(il.spliterator(), false).filter(i -> i.getOpcode() == Opcodes.INVOKESPECIAL).findAny().orElseThrow(() -> new PostprocessException("Constructor does not INVOKESPECIAL its superclass’s constructor (this is an OC-Wasm bug)"));
			if(!Type.getObjectType(invoke.owner).equals(Type.getType(Object.class))) {
				throw new PostprocessException("Constructor as generated does not INVOKESPECIAL to Object (this is an OC-Wasm bug)");
			}
			invoke.owner = MODULE_BASE_TYPE.getInternalName();
			invoke.desc = Type.getMethodDescriptor(Type.VOID_TYPE, LISTENER_TYPE);
			il.insertBefore(invoke, new VarInsnNode(Opcodes.ALOAD, listenerLocalIndex));
		}

		// Modify the constructor’s instructions to handle the new snapshot
		// buffer parameter. We’ll work at the end of the existing instruction
		// list. Preceding instructions invoke the superclass constructor and
		// stash the imports. We have stripped off the original RETURN
		// instruction plus the call to the start function if there is one.
		// That leaves the stack effectively empty (or, if not, we don’t care
		// what’s on it) and the existing code in the perfect place to either
		// call the start function or restore state from the snapshot buffer.

		// Check if the buffer was provided. If not (if the parameter is null),
		// just call the start function and immediately return.

		// Stack: empty (or not, but we don’t care what’s on it)
		il.add(new VarInsnNode(Opcodes.ALOAD, bufferLocalIndex));
		// Stack: ByteBuffer(snapshot)
		final JumpInsnNode ifNonNullJump = new JumpInsnNode(Opcodes.IFNONNULL, null);
		il.add(ifNonNullJump);
		// If we get here, the ByteBuffer parameter is null, so do normal
		// initialization (start function if present, then return).
		// Stack: empty
		il.add(callStartFunctionInsns);
		// Stack: empty
		il.add(new InsnNode(Opcodes.RETURN));
		// Stack: irrelevant
		final LabelNode ifNonNullTarget = new LabelNode();
		ifNonNullJump.label = ifNonNullTarget;
		il.add(ifNonNullTarget);
		// Stack: empty

		// Unpack the globals.
		il.add(new VarInsnNode(Opcodes.ALOAD, bufferLocalIndex));
		// Stack: ByteBuffer(snapshot)
		final List<Node.Global> globals = module.getGlobals();
		for(int i = 0; i != globals.size(); ++i) {
			final Node.Type.Global global = globals.get(i).getType();
			if(global.getMutable()) {
				// Stack: ByteBuffer(snapshot)
				il.add(new InsnNode(Opcodes.DUP));
				// Stack: ByteBuffer(snapshot), ByteBuffer(snapshot)
				il.add(new VarInsnNode(Opcodes.ALOAD, 0));
				// Stack: ByteBuffer(snapshot), ByteBuffer(snapshot), this
				il.add(new InsnNode(Opcodes.SWAP));
				// Stack: ByteBuffer(snapshot), this, ByteBuffer(snapshot)
				il.add(new MethodInsnNode(Opcodes.INVOKEVIRTUAL, BB_TYPE.getInternalName(), "get" + getByteBufferMethodSuffix(global.getContentType()), Type.getMethodDescriptor(convertValueType(global.getContentType())), false));
				// Stack: ByteBuffer(snapshot), this, globalValue
				il.add(new FieldInsnNode(Opcodes.PUTFIELD, node.name, "$global" + i, convertValueType(global.getContentType()).getDescriptor()));
				// Stack: ByteBuffer(snapshot)
			}
		}
		// Stack: ByteBuffer(snapshot)

		il.add(new InsnNode(Opcodes.RETURN));
	}

	/**
	 * Checks whether a given constructor delegates to one of its siblings.
	 *
	 * @param ctor The constructor to consider.
	 * @param classNode The class to consider.
	 * @return {@code true} if {@code ctor} delegates to a sibling, or {@code
	 * false} if not.
	 */
	private static boolean constructorDelegates(final MethodNode ctor, final ClassNode classNode) {
		if(ctor.name.equals("<init>")) {
			return StreamSupport.stream(ctor.instructions.spliterator(), false).anyMatch(i -> i.getOpcode() == Opcodes.INVOKESPECIAL && ((MethodInsnNode) i).name.equals("<init>") && ((MethodInsnNode) i).owner.equals(classNode.name));
		} else {
			throw new IllegalArgumentException("Only constructors can be passed");
		}
	}

	/**
	 * Converts a Wasm value type into an ASM type.
	 *
	 * @param type The Wasm type.
	 * @return The ASM type.
	 */
	private static Type convertValueType(final Node.Type.Value type) {
		if(type instanceof Node.Type.Value.I32) {
			return Type.INT_TYPE;
		} else if(type instanceof Node.Type.Value.I64) {
			return Type.LONG_TYPE;
		} else if(type instanceof Node.Type.Value.F32) {
			return Type.FLOAT_TYPE;
		} else if(type instanceof Node.Type.Value.F64) {
			return Type.DOUBLE_TYPE;
		} else {
			throw new IllegalArgumentException("Unknown Wasm value type " + type);
		}
	}

	/**
	 * Returns the suffix of the methods in {@link ByteBuffer} that are related
	 * to storing a given Wasm value type.
	 *
	 * @param type The Wasm type.
	 * @return The method name suffix.
	 */
	private static String getByteBufferMethodSuffix(final Node.Type.Value type) {
		if(type instanceof Node.Type.Value.I32) {
			return "Int";
		} else if(type instanceof Node.Type.Value.I64) {
			return "Long";
		} else if(type instanceof Node.Type.Value.F32) {
			return "Float";
		} else if(type instanceof Node.Type.Value.F64) {
			return "Double";
		} else {
			throw new IllegalArgumentException("Unknown Wasm value type " + type);
		}
	}

	/**
	 * Checks that all abstract methods in ModuleBase are overridden in the
	 * Wasm module.
	 *
	 * @param node The class being examined.
	 * @throws PostprocessException If a method is missing.
	 */
	private static void checkAllAbstractMethodsOverridden(final ClassNode node) throws PostprocessException {
		for(final Method i : ModuleBase.class.getMethods()) {
			if((i.getModifiers() & Modifier.ABSTRACT) != 0) {
				final Type type = Type.getType(i);
				if(!node.methods.stream().anyMatch(j -> j.name.equals(i.getName()) && type.equals(Type.getType(j.desc)))) {
					throw new PostprocessException("Required function " + i.getName() + " with descriptor " + type.getDescriptor() + " from Wasm module is not exported");
				}
			}
		}
	}

	private Postprocessor() {
	}
}
